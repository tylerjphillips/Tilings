<html>
<head>
	<script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>
	<script>
        let RegularTile = class
		{
  		constructor(name,parent, color, number_of_sides, desired_angle, neighbors)
			{
    		this.name = name;
    		this.parent = parent;
    		this.color = color;
    		this.number_of_sides = number_of_sides;
    		this.angle = desired_angle;
    		this.neighbors = neighbors;
  			}

		generate_shape_values(coords, sidelength, number_of_sides_current, first_shape = false)
		{
		    <!-- Takes an origin, a direction, the sidelength. Returns the xy coordinates and radius of the new polygon -->

		    var old_radii = get_shape_radii(sidelength, number_of_sides_current);
			var shape_angle;

		    <!-- Use the inner radii of both shapes to calculate the vector for where the new shape will lie, then add it to existing coords  -->
			if (!first_shape)
			{
			    var new_radii = get_shape_radii(sidelength, this.number_of_sides);
			    var new_coords = add_directional_vector(coords, this.angle, old_radii[0]+new_radii[0]);
			    shape_angle = get_modified_shape_angle(this.angle, this.number_of_sides);
				return {"x":new_coords[0], "y":new_coords[1], "radius":new_radii[1], "angle":shape_angle, "sides":this.number_of_sides, "color":this.color};
			}
			else
			{
			    shape_angle = get_modified_shape_angle(this.angle, number_of_sides_current);
			    return {"x":coords[0], "y":coords[1],"radius":old_radii[1], "angle":shape_angle, "sides":this.number_of_sides, "color":this.color};
			}
		}
		};

		function get_outer_radius(sidelength, number_of_sides)
        {
            return sidelength / (2 * Math.sin(Math.PI / number_of_sides))
        }

        function get_inner_radius(radius, sidelength)
        {
            /* Gets the inner radius(center to sides) of a regular polygon using pythagorean theorem*/
            return Math.sqrt((radius * radius) - (sidelength * sidelength / 4))
        }

        function get_shape_radii(sidelength, number_of_sides)
		{
		    /* 	Get both the inner and outer radii of a regular polygon
		     	First use the sidelength and number of sides to get the outer radius
		     	Then use the outer radius and sidelength to get the inner radius	*/
		    var outer_radius = get_outer_radius(sidelength, number_of_sides);
            var inner_radius = get_inner_radius(outer_radius, sidelength);
            return [inner_radius, outer_radius]
		}

        function polar_to_cartesian(direction, magnitude) {
            /* creates an x,y vector given a direction(degrees) and a magnitude */
            var dir = direction
            var x = magnitude * Math.cos((dir / 360) * 2 * Math.PI)
            var y = magnitude * Math.sin((dir / 360) * 2 * Math.PI)
            return [x, y]
        }

        function point_direction(coord1, coord2) {
            <!-- returns the angle in degrees from two coordinates -->
            var dy = coord2[1] - coord1[1]
            var dx = coord2[0] - coord1[0]
			var a = Math.atan2(dy, dx);
            while (a < 0.0)
                a += math.pi * 2;

            return a * 180 / Math.PI
        }

        function add_directional_vector(coords, direction, magnitude)
        {
            /* Takes [x,y] adds a vector to it and returns the new [x,y] */
            var vector = polar_to_cartesian(direction,magnitude)
            return [coords[0] + vector[0], coords[1] + vector[1]]
        }

        function get_modified_shape_angle(direction, number_of_sides)
		{
		    <!-- Gives an angular offset value for drawing polygons. Even numbered shapes have an offset while odd doesn't  -->
		    return direction + ((number_of_sides % 2) == 0 ? (360 / (number_of_sides * 2)) : 0)
		}

		function generate_initial_chunk_data(sidelength, shapes)
		{
		    var chunk_data = {};

		    /* Generates shapes from a list and adds them to canvas */
			var current_number_of_sides;
			if (shapes.length > 0)
			{
			    var current_number_of_sides = shapes[0].number_of_sides;

				/* Generate values of first shape in the sequence */
			    var polygon_values = shapes[0].generate_shape_values([0,0], sidelength, current_number_of_sides, true);

			    /* add rendering data to chunk */
			    chunk_data[shapes[0].name] = polygon_values;

                for (var i = 1; i < shapes.length; i++)
				{
				    /* Feed coordinates and number of sides of the parent of current shape back into function*/
					var parent = shapes[i].parent;

					var coords = [chunk_data[parent]["x"]	, chunk_data[parent]["y"]]
					current_number_of_sides = chunk_data[parent]["sides"];

				    polygon_values = shapes[i].generate_shape_values(coords, sidelength, current_number_of_sides, false);

				    /* add rendering data to chunk */
				    chunk_data[shapes[i].name] = polygon_values;
				}

			return chunk_data;
			}
		}

		function render_chunk(xoffset, yoffset, canvas, chunk_data)
		{
		for (var [name, shape] of Object.entries(chunk_data))
			{
			    polygon = new createjs.Shape();
				polygon.graphics.beginFill(shape["color"]).drawPolyStar(shape["x"]+xoffset, shape["y"]+yoffset, shape["radius"], shape["sides"], 0, shape["angle"]);
				canvas.addChild(polygon);
			}
		    canvas.update()
		}

		function init()
		{
            var sidelength = 20;
			var stage = new createjs.Stage("demoCanvas");

			/* shape("name","color",sides, angle, neighbors=[]) */
			shape_data = [
			    new RegularTile("A",null, "blue", 6, 0, []),
				new RegularTile("B","A", "green", 4, 0, []),
				new RegularTile("C","B", "red", 6, 0, []),
				new RegularTile("D","C", "blue", 4, 0, []),
				new RegularTile("E","C", "green", 4, 240, []),
				new RegularTile("F","E", "red", 4, 240, []),
				new RegularTile("G","B", "blue", 4, 90, []),
			];

			chunk_data = generate_initial_chunk_data(sidelength, shape_data);

			chunk_height = 95;
			chunk_vertical_count = 1;
			chunk_width = 55;
			chunk_horizontal_count = 1;

			var x = 60;
			var y = 60;

			for(var i = 0; i < chunk_vertical_count; i++)
			{
			    for(var j = 0; j < chunk_horizontal_count; j++)
				{
				    render_chunk(x,y,stage, chunk_data);
				    x += chunk_width;
				}
				y += chunk_height;
			    x = 60;
			}


		}
	</script>
</head>
<body onload="init();">
	<canvas id="demoCanvas" width="1000" height="1000">
		alternate content
	</canvas>

</body></html>